/*
 * This file is part of the xPack project (http://xpack.github.io).
 * Copyright (c) 2025 Liviu Ionescu. All rights reserved.
 *
 * Permission to use, copy, modify, and/or distribute this software
 * for any purpose is hereby granted, under the terms of the MIT license.
 *
 * If a copy of the license was not distributed with this file, it can
 * be obtained from https://opensource.org/licenses/MIT.
 */

const { readdir, createReadStream, writeFile } = require('fs-extra')
const { createInterface } = require('readline')
const { join, parse } = require('path')
const path = require('path')
const fs = require('fs/promises')
const util = require('util')

// This script is a tool to rewrite some parts of the docs generated
// by api-generator and api-documenter so they work with the website
// generated by Docusaurus.

// This runs in the website folder.
const apiJsonFilePath = '../api-extractor/doxygen2docusaurus.api.json'
const sidebarFilePath = 'sidebar-category-tsdoc.json'

const inputFolderPath = '../api-extractor/markdown'
const docsRelativeFolderPath = 'docs'
const apiRelativeFolderPath = 'api'
const outputFolderPath = `${docsRelativeFolderPath}/${apiRelativeFolderPath}`

const baseUrl = '/doxygen2docusaurus-ts/'

// ----------------------------------------------------------------------------

async function parseApiDataModel() {
  // Parse the API JSON file
  let apiDataModel = null
  try {
    const apiJsonContent = await fs.readFile(apiJsonFilePath, 'utf8')
    apiDataModel = JSON.parse(apiJsonContent)
  } catch (err) {
    console.warn(
      `Could not parse API JSON file ${apiJsonFilePath}: ${err.message}`
    )
    return null
  }

  return apiDataModel
}

// ----------------------------------------------------------------------------

function prepareApiViewModel(apiDataModel) {
  const entryPointsSet = new Set()

  // Key paths do not start with '/', permalinks are absolute (start with baseUrl).
  const permalinksMapByPath = new Map()

  const topIndex = {
    kind: 'TopIndex',

    inputFilePath: 'index.md',
    permalink: `${baseUrl}${outputFolderPath}`,

    frontMatterSlug: '/api',
    frontMatterTitle: 'API Reference',

    sidebarLabel: 'API Reference (TSDoc',
    sidebarId: `${apiRelativeFolderPath}/index`,

    outputFilePath: 'index.md',
  }

  permalinksMapByPath.set(topIndex.inputFilePath, topIndex.permalink)

  for (const entryPointDataModel of apiDataModel.members) {
    // console.log(entryPointDataModel.kind, entryPointDataModel.canonicalReference);

    entryPointKind = entryPointDataModel.kind
    const entryPointLabel = entryPointDataModel.canonicalReference.replace(
      /[!]$/,
      ''
    )
    const entryPointId = entryPointLabel.replace(/^.*\//, '').toLowerCase()

    const inputFilePath = `${entryPointId}.md`
    const permalink = `${baseUrl}${outputFolderPath}/${entryPointId}`
    permalinksMapByPath.set(inputFilePath, permalink)

    const frontMatterSlug = `/api/${entryPointId}`
    const frontMatterTitle = `${entryPointId} package`

    const sidebarLabel = entryPointLabel
    const sidebarId = `${apiRelativeFolderPath}/${entryPointId}`

    const outputFilePath = `${entryPointId}.md`

    const entryPoint = {
      kind: entryPointKind,

      inputFilePath,
      permalink,

      frontMatterSlug,
      frontMatterTitle,

      sidebarLabel,
      sidebarId,

      outputFilePath,

      compoundsMap: new Map(), // Map of array of compounds, by kind (Class, Interface, ...)
      data: entryPointDataModel,
    }
    entryPointsSet.add(entryPoint)

    for (const compoundDataModel of entryPointDataModel.members) {
      // console.log(compoundDataModel.kind, compoundDataModel.name, compoundDataModel.canonicalReference);

      const compoundKind = compoundDataModel.kind
      const compoundLabel = compoundDataModel.name
      const compoundId = compoundDataModel.name.toLowerCase()

      const compoundCategoryId = pluralise(compoundKind).toLowerCase()

      const inputFilePath = `${entryPointId}.${compoundId}.md`
      const permalink = `${baseUrl}${outputFolderPath}/${entryPointId}/${compoundCategoryId}/${compoundId}`
      permalinksMapByPath.set(inputFilePath, permalink)

      const frontMatterSlug = `/api/${entryPointId}/${compoundCategoryId}/${compoundId}`

      let compoundTitle = compoundLabel
      if (compoundKind === 'Function') {
        compoundTitle += '()'
      }

      const frontMatterTitle = `${compoundTitle} ${compoundKind.toLowerCase()}`

      const sidebarLabel = compoundLabel
      const sidebarId = `${apiRelativeFolderPath}/${entryPointId}/${compoundCategoryId}/${compoundId}`

      const outputFilePath = `${entryPointId}/${compoundCategoryId}/${compoundId}.md`

      const compound = {
        kind: compoundKind,

        inputFilePath,
        permalink,

        frontMatterSlug,
        frontMatterTitle,

        sidebarLabel,
        sidebarId,

        outputFilePath,

        membersMap: new Map(), // Map of array of members, by kind (Constructor, Property, ...)
        data: compoundDataModel,
      }

      let compoundsArray = entryPoint.compoundsMap.get(compoundDataModel.kind)
      if (compoundsArray === undefined) {
        compoundsArray = []
        entryPoint.compoundsMap.set(compound.kind, compoundsArray)
      }
      compoundsArray.push(compound)

      if (compoundDataModel.members !== undefined) {
        for (const memberDataModel of compoundDataModel.members) {
          // console.log('  ', memberDataModel.kind, memberDataModel.name, memberDataModel.canonicalReference);

          const memberKind = memberDataModel.kind
          let memberLabel = memberDataModel.name

          let originalMemberId = memberDataModel.name

          let memberId
          if (memberLabel !== undefined) {
            originalMemberId = memberLabel
              .replaceAll(/[^a-zA-Z0-9]/g, '_')
              .toLowerCase()

            memberId = originalMemberId

            // Docusaurus ignores files that start with an underscore.
            // Surround with $ if the original name contains non-alphanumeric characters
            if (/^_/.test(originalMemberId)) {
              memberId = `$${memberId}$`
            }
          }

          // const memberCategoryId = pluralise(memberKind).toLowerCase()
          // console.log(memberCategoryId)

          let memberTitle = memberLabel

          if (memberKind === 'Constructor') {
            memberId = '$constructor$'
            memberTitle = '(constructor)'
            originalMemberId = '_constructor_'
          }

          // if (originalMemberId === undefined) {
          //   console.log(memberDataModel)
          // }

          const inputFilePath = `${entryPointId}.${compoundId}.${originalMemberId}.md`
          const permalink = `${baseUrl}${outputFolderPath}/${entryPointId}/${compoundCategoryId}/${compoundId}/${memberId}`
          if (memberKind !== 'CallSignature') {
            // if(originalMemberId === undefined) {
            //   console.log(memberDataModel)
            // }
            permalinksMapByPath.set(inputFilePath, permalink)
          }

          const frontMatterSlug = `/api/${entryPointId}/${compoundCategoryId}/${compoundId}/${memberId}`

          if (memberKind === 'Method') {
            memberTitle += '()'
          }

          let titleKind = memberKind
          if (titleKind === 'PropertySignature') {
            titleKind = 'Property'
          }

          const frontMatterTitle =
            memberKind !== 'Constructor'
              ? `${compoundLabel}.${memberTitle} ${titleKind.toLowerCase()}`
              : `${compoundLabel}.${memberTitle}`

          const sidebarLabel = memberTitle
          const sidebarId = `${apiRelativeFolderPath}/${entryPointId}/${compoundCategoryId}/${compoundId}/${memberId}`

          const outputFilePath = `${entryPointId}/${compoundCategoryId}/${compoundId}/${memberId}.md`

          const member = {
            kind: memberKind,

            inputFilePath,
            permalink,

            frontMatterSlug,
            frontMatterTitle,

            sidebarLabel,
            sidebarId,

            outputFilePath,

            data: memberDataModel,
          }

          if (memberId === undefined) {
            member.isHidden = true
          }

          let membersArray = compound.membersMap.get(member.kind)
          if (membersArray === undefined) {
            membersArray = []
            compound.membersMap.set(member.kind, membersArray)
          }

          membersArray.push(member)
        }
      }
    }
  }

  // for (const [keyPath, permalink] of permalinksMapByPath) {
  //   console.log(keyPath, '=>', permalink)
  // }

  return {
    topIndex,
    entryPointsSet,
    permalinksMapByPath,
  }
}

// ----------------------------------------------------------------------------

async function readInputFileLines(filePath) {
  const inputData = await fs.readFile(filePath, 'utf8')
  return inputData.split('\n').map((line) => line.trimEnd())
}

async function writeOutputFile(filePath, frontMatter, lines) {
  const header = [
    '---',
    // '',
    // '# DO NOT EDIT!',
    // '# Automatically generated via tsdoc2docusaurus by API Documenter.',
    // '',
    `slug: ${frontMatter.slug}`,
    `title: ${frontMatter.title}`,
    'custom_edit_url: null',
    '---',
    '',
    '<div class="tsdocPage">',
    '',
  ]

  const footer = ['</div>']

  const outputContent = header.concat(lines).concat(footer).join('\n')
  await fs.mkdir(path.dirname(filePath), { recursive: true })
  await fs.writeFile(filePath, outputContent, 'utf8')
  console.log(`Writing ${filePath}...`)
}

function patchLines(lines, permalinksMapByPath) {
  const outLines = []

  let firstH2 = false

  for (const line of lines) {
    if (line.match(/^\[Home\]\(\.\/index\.md\)/)) {
      continue // Skip the home link
    } else if (!firstH2 && line.startsWith('## ')) {
      firstH2 = true
      continue
    } else if (line.startsWith('**Signature:**')) {
      // Convert the signature line to a H2
      outLines.push('## Signature')
    } else {
      // Patch links and other formatting
      outLines.push(patchPermalinks(line, permalinksMapByPath))
    }
  }
  return outLines
}

function patchPermalinks(line, permalinksMapByPath) {
  let patchedLine = line

  const matches = [...line.matchAll(/\]\([^\(<>\)]*\)/g)]
  if (matches.length > 0) {
    // console.log(matches)
    for (const match of matches) {
      const link = match[0]
      const linkPath = link.slice(2, -1) // Remove the leading `](` and trailing `)`
      if (linkPath.startsWith('./')) {
        // Relative link, patch it
        const relativePath = linkPath.slice(2)
        if (permalinksMapByPath.has(relativePath)) {
          const permalink = permalinksMapByPath.get(relativePath)
          // console.log(relativePath, '->', permalink)
          patchedLine = patchedLine.replace(link, `](${permalink})`)
          // console.log(patchedLine)
        } else {
          console.warn(`No permalink for ${relativePath}, skipping patch.`)
        }
      }
    }
  }

  return patchedLine
}

async function generateMdFiles(apiViewModel) {
  const entryPointsSet = apiViewModel.entryPointsSet

  {
    const topIndex = apiViewModel.topIndex
    const lines = await readInputFileLines(
      `${inputFolderPath}/${topIndex.inputFilePath}`
    )

    const patchLinesLines = patchLines(lines, apiViewModel.permalinksMapByPath)

    const frontMatter = {
      slug: topIndex.frontMatterSlug,
      title: topIndex.frontMatterTitle,
    }

    await writeOutputFile(
      `${outputFolderPath}/${topIndex.outputFilePath}`,
      frontMatter,
      patchLinesLines
    )
  }

  // --------------------------------------------------------------------------

  for (const entryPoint of entryPointsSet) {
    // console.log(entryPoint)

    const lines = await readInputFileLines(
      `${inputFolderPath}/${entryPoint.inputFilePath}`
    )

    const patchLinesLines = patchLines(lines, apiViewModel.permalinksMapByPath)

    const frontMatter = {
      slug: entryPoint.frontMatterSlug,
      title: entryPoint.frontMatterTitle,
    }

    await writeOutputFile(
      `${outputFolderPath}/${entryPoint.outputFilePath}`,
      frontMatter,
      patchLinesLines
    )

    // ------------------------------------------------------------------------

    for (const [compoundKind, compoundsArray] of entryPoint.compoundsMap) {
      const compoundCategoryLabel = pluralise(compoundKind)
      // console.log(`  ${compoundCategoryLabel}`)

      for (const compound of compoundsArray) {
        // console.log(`    ${compound.label}`)

        const lines = await readInputFileLines(
          `${inputFolderPath}/${compound.inputFilePath}`
        )

        const patchLinesLines = patchLines(
          lines,
          apiViewModel.permalinksMapByPath
        )

        const frontMatter = {
          slug: compound.frontMatterSlug,
          title: compound.frontMatterTitle,
        }

        // TODO: Insert members into compound (future improvement).

        await writeOutputFile(
          `${outputFolderPath}/${compound.outputFilePath}`,
          frontMatter,
          patchLinesLines
        )

        // --------------------------------------------------------------------

        if (compound.membersMap !== undefined && compound.membersMap.size > 0) {
          for (const [memberKind, membersArray] of compound.membersMap) {
            for (const member of membersArray) {
              if (member.isHidden) {
                continue
              }

              // console.log(`      ${member.label} ${member.name} ${member.id}`)

              const lines = await readInputFileLines(
                `${inputFolderPath}/${member.inputFilePath}`
              )

              const patchLinesLines = patchLines(
                lines,
                apiViewModel.permalinksMapByPath
              )

              const frontMatter = {
                slug: member.frontMatterSlug,
                title: member.frontMatterTitle,
              }

              await writeOutputFile(
                `${outputFolderPath}/${member.outputFilePath}`,
                frontMatter,
                patchLinesLines
              )
            }
          }
        }
      }
    }
  }
}

// ----------------------------------------------------------------------------

function generateSidebarCategory(apiViewModel) {
  const entryPointsSet = apiViewModel.entryPointsSet

  const topIndex = apiViewModel.topIndex

  const sidebarTopCategory = {
    type: 'category',
    label: topIndex.sidebarLabel,
    link: {
      type: 'doc',
      id: topIndex.sidebarId,
    },
    collapsed: false,
    items: [],
  }

  for (const entryPoint of entryPointsSet) {
    const entryPointCategory = {
      type: 'category',
      label: entryPoint.sidebarLabel,
      link: {
        type: 'doc',
        id: entryPoint.sidebarId,
      },
      collapsed: false,
      items: [],
    }
    sidebarTopCategory.items.push(entryPointCategory)

    for (const [kind, compoundsArray] of entryPoint.compoundsMap) {
      const compoundCategoryLabel = pluralise(kind)
      const kindCategory = {
        type: 'category',
        label: compoundCategoryLabel,
        collapsed: true,
        items: [],
      }
      entryPointCategory.items.push(kindCategory)

      for (const compound of compoundsArray) {
        const compoundCategory = {
          type: 'category',
          label: compound.sidebarLabel,
          link: {
            type: 'doc',
            id: compound.sidebarId,
          },
          collapsed: true,
          items: [],
        }
        kindCategory.items.push(compoundCategory)

        if (compound.membersMap !== undefined && compound.membersMap.size > 0) {
          for (const [memberKind, membersArray] of compound.membersMap) {
            for (const member of membersArray) {
              if (member.isHidden) {
                // console.warn(`Skipping member without name in ${compoundLabel}: ${member.data.canonicalReference}`);
                continue
              }

              const memberDoc = {
                type: 'doc',
                id: `${member.sidebarId}`,
                label: member.sidebarLabel,
              }
              compoundCategory.items.push(memberDoc)
            }
          }
        }
      }
    }
  }

  return sidebarTopCategory
}

// ----------------------------------------------------------------------------

async function legacy() {
  const mdFilesNames = await readdir(inputFolderPath)
  for (const mdFileName of mdFilesNames) {
    try {
      const { name: id, ext } = parse(mdFileName)
      if (ext !== '.md') {
        continue
      }

      const mdInputFilePath = join(inputFolderPath, mdFileName)
      const inputStream = createReadStream(mdInputFilePath)

      const output = []
      const lines = createInterface({
        input: inputStream,
        crlfDelay: Infinity,
      })

      let title = ''
      let firstH2 = false
      let signature = false

      lines.on('line', (line) => {
        if (line.startsWith('## ') && !firstH2) {
          firstH2 = true
          const titleLine = line.match(/## (.*)/)
          if (titleLine) {
            title = titleLine[1]
          }
        } else {
          const homeLink = line.match(/^\[Home\]\(\.\/index\.md\)/)
          if (!homeLink) {
            if (line.startsWith('**Signature:**') && !signature) {
              signature = true
              line = '## Signature'
            }

            // See issue #4. api-documenter expects \| to escape table
            // column delimiters, but docusaurus uses a markdown processor
            // that doesn't support this. Replace with an escape sequence
            // that renders |.
            if (line.startsWith('|')) {
              line = line.replace(/\\\|/g, '&#124;')
            }
            line = patchPermalinks(line)

            output.push(line)
          }
        }
      })

      await new Promise((resolve) => lines.once('close', resolve))
      inputStream.close()

      const slug =
        id === 'index'
          ? '/api'
          : `/api/${id.replace(/\./g, '/').replaceAll(/_constructor_/g, '$constructor$')}`

      const header = [
        '---',
        `slug: ${slug}`,
        `title: ${title}`,
        'custom_edit_url: null',
        '---',
        '',
        '<div class="tsdocPage">',
        '',
      ]

      const footer = ['', '</div>']

      const mdOutputId = id
        .replace(/\./g, '/')
        .replaceAll(/_constructor_/g, '$constructor$')
      const mdOutputIdDirname = path.dirname(mdOutputId)
      let mdOutputIdBasename = path.basename(mdOutputId)
      if (/[^a-zA-Z0-9$]/.test(mdOutputIdBasename)) {
        mdOutputIdBasename = `$${mdOutputIdBasename}$`
      }

      const mdOutFilePath = join(mdOutputIdDirname, mdOutputIdBasename) + '.md'

      const mdOutFolderPath = path.dirname(
        path.join(outputFolderPath, mdOutFilePath)
      )
      await fs.mkdir(mdOutFolderPath, { recursive: true })

      const docFilePath = join(outputFolderPath, mdOutFilePath)
      // console.log(`Writing ${docFilePath}...`)
      await writeFile(
        docFilePath,
        header.concat(output).concat(footer).join('\n')
      )
    } catch (err) {
      console.error(`Could not process ${mdFileName}: ${err}`)
    }
  }
}

// ----------------------------------------------------------------------------

function pluralise(name) {
  const plurals = {
    Class: 'Classes',
    Interface: 'Interfaces',
    Function: 'Functions',
    Variable: 'Variables',
    'Type alias': 'Type aliases',
    Namespace: 'Namespaces',
    Enum: 'Enums',
    Method: 'Methods',
    Property: 'Properties',
  }

  if (plurals[name] !== undefined) {
    return plurals[name]
  }

  console.warn(`No plural for ${name}, using default.`)
  return name + 's?'
}

// ----------------------------------------------------------------------------

async function main() {
  // Parse the API JSON file
  const apiDataModel = await parseApiDataModel()
  if (apiDataModel === null) {
    return 1
  }

  const apiViewModel = prepareApiViewModel(apiDataModel)

  const sidebar = generateSidebarCategory(apiViewModel)
  // console.log(util.inspect(sidebar, { compact: false, depth: 999 }));

  // Write the sidebar to file
  try {
    console.log(`Writing sidebar file ${sidebarFilePath}`)
    const sidebarJson = JSON.stringify(sidebar, null, 2)
    await writeFile(sidebarFilePath, sidebarJson)
  } catch (err) {
    console.error(
      `Could not write sidebar file ${sidebarFilePath}: ${err.message}`
    )
    return 1
  }

  // process.exit(0);

  await generateMdFiles(apiViewModel)

  // await legacy()

  return 0
}

// ----------------------------------------------------------------------------

main()

// try {
//   process.exit(main())
// } catch (err) {
//   console.error(`Error in convert-docs.cjs: ${err.message}`);
//   process.exit(1);
// }

// ----------------------------------------------------------------------------
