/*
 * This file is part of the xPack project (http://xpack.github.io).
 * Copyright (c) 2025 Liviu Ionescu. All rights reserved.
 *
 * Permission to use, copy, modify, and/or distribute this software
 * for any purpose is hereby granted, under the terms of the MIT license.
 *
 * If a copy of the license was not distributed with this file, it can
 * be obtained from https://opensource.org/licenses/MIT.
 */

const { readdir, createReadStream, writeFile } = require('fs-extra')
const { createInterface } = require('readline')
const { join, parse } = require('path')
const path = require('path')
const fs = require('fs/promises')
const util = require('util')

// This script is a tool to rewrite some parts of the docs generated
// by api-generator and api-documenter so they work with the website
// generated by Docusaurus.

// This runs in the website folder.
const apiJsonFilePath = '../api-extractor/doxygen2docusaurus.api.json'
const sidebarFilePath = 'sidebar-category-tsdoc.json'

const inputFolderPath = '../api-extractor/markdown'
const docsRelativeFolderPath = 'docs'
const apiRelativeFolderPath = 'api'
const outputFolderPath = `${docsRelativeFolderPath}/${apiRelativeFolderPath}`

const baseUrl = '/doxygen2docusaurus-ts/'

// ----------------------------------------------------------------------------

function patchLine(line) {
  return line
    .replaceAll(
      /\]\(\.\/([a-z0-9]*[^)]*)\)/g,
      `](${baseUrl}${outputFolderPath}/$1)`
    )
    .replaceAll(/\.md\)/g, ')')
    .replaceAll(
      /\]\(([^)]*)\)/g,
      (match, content) => `](${content.replace(/\./g, '/')})`
    )
    .replaceAll(/_constructor_/g, '$constructor$')
}

function pluralise(name) {
  const plurals = {
    Class: 'Classes',
    Interface: 'Interfaces',
    Function: 'Functions',
    Variable: 'Variables',
    'Type alias': 'Type aliases',
    Namespace: 'Namespaces',
    Enum: 'Enums',
    Method: 'Methods',
    Property: 'Properties',
  }

  if (plurals[name] !== undefined) {
    return plurals[name]
  }

  console.warn(`No plural for ${name}, using default.`)
  return name + 's?'
}

// ----------------------------------------------------------------------------

async function parseApiDataModel() {
  // Parse the API JSON file
  let apiDataModel = null
  try {
    const apiJsonContent = await fs.readFile(apiJsonFilePath, 'utf8')
    apiDataModel = JSON.parse(apiJsonContent)
  } catch (err) {
    console.warn(
      `Could not parse API JSON file ${apiJsonFilePath}: ${err.message}`
    )
    return null
  }

  return apiDataModel
}

function prepareApiViewModel(apiDataModel) {
  const entryPointsSet = new Set()
  for (const entryPointDataModel of apiDataModel.members) {
    // console.log(entryPointDataModel.kind, entryPointDataModel.canonicalReference);

    entryPointKind = entryPointDataModel.kind
    const entryPointLabel = entryPointDataModel.canonicalReference.replace(
      /[!]$/,
      ''
    )
    const entryPointId = entryPointLabel.replace(/^.*\//, '').toLowerCase()

    const entryPoint = {
      kind: entryPointKind,
      label: entryPointLabel,
      id: entryPointId,
      compoundsMap: new Map(), // Map of array of compounds, by kind (Class, Interface, ...)
      data: entryPointDataModel,
    }
    entryPointsSet.add(entryPoint)

    for (const compoundDataModel of entryPointDataModel.members) {
      // console.log(compoundDataModel.kind, compoundDataModel.name, compoundDataModel.canonicalReference);

      const compoundKind = compoundDataModel.kind
      const compoundLabel = compoundDataModel.name
      const compoundId = compoundDataModel.name.toLowerCase()

      const compound = {
        kind: compoundKind,
        label: compoundLabel,
        id: compoundId,
        membersMap: new Map(), // Map of array of members, by kind (Constructor, Property, ...)
        data: compoundDataModel,
      }

      let compoundsArray = entryPoint.compoundsMap.get(compoundDataModel.kind)
      if (compoundsArray === undefined) {
        compoundsArray = []
        entryPoint.compoundsMap.set(compound.kind, compoundsArray)
      }
      compoundsArray.push(compound)

      if (compoundDataModel.members !== undefined) {
        for (const memberDataModel of compoundDataModel.members) {
          // console.log('  ', memberDataModel.kind, memberDataModel.name, memberDataModel.canonicalReference);

          const memberName = memberDataModel.name
          const memberKind = memberDataModel.kind
          let memberLabel = memberDataModel.name

          let memberId
          if (memberLabel !== undefined) {
            memberId = memberLabel
              .replaceAll(/[^a-zA-Z0-9]/g, '_')
              .toLowerCase()

            // Surround with $ if the original name contains non-alphanumeric characters
            if (/[^a-zA-Z0-9]/.test(memberDataModel.name)) {
              memberId = `$${memberId}$`
            }
          }

          if (memberKind === 'Constructor') {
            memberLabel = 'constructor'
            memberId = '$constructor$'
          }

          const member = {
            kind: memberKind,
            name: memberName,
            label: memberLabel,
            id: memberId,
            data: memberDataModel,
          }

          let membersArray = compound.membersMap.get(member.kind)
          if (membersArray === undefined) {
            membersArray = []
            compound.membersMap.set(member.kind, membersArray)
          }

          membersArray.push(member)
        }
      }
    }
  }
  return {
    entryPointsSet,
  }
}

// ----------------------------------------------------------------------------

async function readInputFileLines(filePath) {
  const inputData = await fs.readFile(filePath, 'utf8')
  return inputData.split('\n')
}

async function writeOutputFile(filePath, frontMatter, lines) {
  const header = [
    '---',
    // '',
    // '# DO NOT EDIT!',
    // '# Automatically generated via tsdoc2docusaurus by API Documenter.',
    // '',
    `slug: ${frontMatter.slug}`,
    `title: ${frontMatter.title}`,
    'custom_edit_url: null',
    '---',
    '',
    '<div class="tsdocPage">',
    '',
  ]

  const footer = ['</div>']

  const outputContent = header.concat(lines).concat(footer).join('\n')
  await fs.mkdir(path.dirname(filePath), { recursive: true })
  await fs.writeFile(filePath, outputContent, 'utf8')
  console.log(`Writing ${filePath}...`)
}

function patchLines(lines) {
  const outLines = []

  let firstH2 = false

  for (const line of lines) {
    if (line.match(/^\[Home\]\(\.\/index\.md\)/)) {
      continue // Skip the home link
    } else if (!firstH2 && line.startsWith('## ')) {
      firstH2 = true
      continue
    } else if (line.startsWith('**Signature:**')) {
      // Convert the signature line to a H2
      outLines.push('## Signature')
    } else {
      // Patch links and other formatting
      outLines.push(patchLine(line))
    }
  }
  return outLines
}

async function generateMdFiles(apiViewModel) {
  const entryPointsSet = apiViewModel.entryPointsSet

  {
    const lines = await readInputFileLines(`${inputFolderPath}/index.md`)
    const frontMatter = {
      slug: `/api`,
      title: `API Reference`,
    }
    const patchLinesLines = patchLines(lines)
    await writeOutputFile(
      `${outputFolderPath}/index.md`,
      frontMatter,
      patchLinesLines
    )
  }

  for (const entryPoint of entryPointsSet) {
    // console.log(entryPoint)

    const lines = await readInputFileLines(
      `${inputFolderPath}/${entryPoint.id}.md`
    )
    const patchLinesLines = patchLines(lines)
    const frontMatter = {
      slug: `/api/${entryPoint.id}`,
      title: `${entryPoint.id} package`,
    }
    await writeOutputFile(
      `${outputFolderPath}/${entryPoint.id}.md`,
      frontMatter,
      patchLinesLines
    )

    for (const [compoundKind, compoundsArray] of entryPoint.compoundsMap) {
      const compoundCategoryLabel = pluralise(compoundKind)
      // console.log(`  ${compoundCategoryLabel}`)

      for (const compound of compoundsArray) {
        // console.log(`    ${compound.label}`)
        const lines = await readInputFileLines(
          `${inputFolderPath}/${entryPoint.id}.${compound.id}.md`
        )
        const patchLinesLines = patchLines(lines)
        let comoundTitle = compound.label
        if (compound.kind === 'Function') {
          comoundTitle += '()'
        }
        const frontMatter = {
          slug: `/api/${entryPoint.id}/${compound.id}`,
          title: `${comoundTitle} ${compound.kind.toLowerCase()}`,
        }

        // TODO: Insert members into compound (future improvement).

        await writeOutputFile(
          `${outputFolderPath}/${entryPoint.id}/${compound.id}.md`,
          frontMatter,
          patchLinesLines
        )

        if (compound.membersMap !== undefined && compound.membersMap.size > 0) {
          for (const [memberKind, membersArray] of compound.membersMap) {
            for (const member of membersArray) {
              if (member.kind === 'CallSignature') {
                continue
              }
              const memberLabel = member.label
              // console.log(`      ${memberLabel} ${member.name} ${member.id}`)

              let originalMemberId = member.id
              let memberTitle = memberLabel
              if (member.id === '$constructor$') {
                originalMemberId = '_constructor_'
                memberTitle = '(constructor)'
              } else if (member.id.startsWith('$') && member.id.endsWith('$')) {
                originalMemberId = member.id.slice(1, -1)
              } else if (member.kind === 'Method') {
                memberTitle += '()'
              }

              const lines = await readInputFileLines(
                `${inputFolderPath}/${entryPoint.id}.${compound.id}.${originalMemberId}.md`
              )

              const patchLinesLines = patchLines(lines)

              const slug = `/api/${entryPoint.id}/${compound.id}/${member.id}`
              let titleKind = member.kind
              if (titleKind === 'PropertySignature') {
                titleKind = 'Property'
              }

              const title =
                member.kind !== 'Constructor'
                  ? `${compound.label}.${memberTitle} ${titleKind.toLowerCase()}`
                  : `${compound.label}.${memberTitle}`
              const frontMatter = {
                slug,
                title,
              }

              let memberId = member.id
              // if (/[^a-zA-Z0-9]/.test(memberId)) {
              //   memberId = `$${memberId}$`
              // }

              await writeOutputFile(
                `${outputFolderPath}/${entryPoint.id}/${compound.id}/${memberId}.md`,
                frontMatter,
                patchLinesLines
              )
            }
          }
        }
      }
    }
  }
}

// ----------------------------------------------------------------------------

function generateSidebarCategory(apiViewModel) {
  const entryPointsSet = apiViewModel.entryPointsSet

  const sidebarTopCategory = {
    type: 'category',
    label: 'API Reference (TSDoc)',
    link: {
      type: 'doc',
      id: `${apiRelativeFolderPath}/index`,
    },
    collapsed: false,
    items: [],
  }

  for (const entryPoint of entryPointsSet) {
    const entryPointCategory = {
      type: 'category',
      label: entryPoint.label,
      link: {
        type: 'doc',
        id: `${apiRelativeFolderPath}/${entryPoint.id}`,
      },
      collapsed: false,
      items: [],
    }
    sidebarTopCategory.items.push(entryPointCategory)

    for (const [kind, compoundsArray] of entryPoint.compoundsMap) {
      const compoundCategoryLabel = pluralise(kind)
      const kindCategory = {
        type: 'category',
        label: compoundCategoryLabel,
        collapsed: true,
        items: [],
      }
      entryPointCategory.items.push(kindCategory)

      for (const compound of compoundsArray) {
        const compoundCategory = {
          type: 'category',
          label: compound.label,
          link: {
            type: 'doc',
            id: `${entryPointCategory.link.id}/${compound.id}`,
          },
          collapsed: true,
          items: [],
        }
        kindCategory.items.push(compoundCategory)

        if (compound.membersMap !== undefined && compound.membersMap.size > 0) {
          for (const [memberKind, membersArray] of compound.membersMap) {
            for (const member of membersArray) {
              let memberLabel = member.label
              let memberId = member.id

              if (member.kind === 'Constructor') {
                memberId = '$constructor$'
                memberLabel = '(constructor)'
              }
              if (memberId === undefined) {
                // console.warn(`Skipping member without name in ${compoundLabel}: ${member.data.canonicalReference}`);
                continue // Skip members without an id
              }
              // if (/[^a-zA-Z0-9]/.test(memberId)) {
              //   memberId = `$${memberId}$`
              // }
              const memberDoc = {
                type: 'doc',
                id: `${entryPointCategory.link.id}/${compound.id}/${memberId}`,
                label: memberLabel,
              }
              compoundCategory.items.push(memberDoc)
            }
          }
        }
      }
    }
  }

  return sidebarTopCategory
}

// ----------------------------------------------------------------------------

async function legacy() {
  const mdFilesNames = await readdir(inputFolderPath)
  for (const mdFileName of mdFilesNames) {
    try {
      const { name: id, ext } = parse(mdFileName)
      if (ext !== '.md') {
        continue
      }

      const mdInputFilePath = join(inputFolderPath, mdFileName)
      const inputStream = createReadStream(mdInputFilePath)

      const output = []
      const lines = createInterface({
        input: inputStream,
        crlfDelay: Infinity,
      })

      let title = ''
      let firstH2 = false
      let signature = false

      lines.on('line', (line) => {
        if (line.startsWith('## ') && !firstH2) {
          firstH2 = true
          const titleLine = line.match(/## (.*)/)
          if (titleLine) {
            title = titleLine[1]
          }
        } else {
          const homeLink = line.match(/^\[Home\]\(\.\/index\.md\)/)
          if (!homeLink) {
            if (line.startsWith('**Signature:**') && !signature) {
              signature = true
              line = '## Signature'
            }

            // See issue #4. api-documenter expects \| to escape table
            // column delimiters, but docusaurus uses a markdown processor
            // that doesn't support this. Replace with an escape sequence
            // that renders |.
            if (line.startsWith('|')) {
              line = line.replace(/\\\|/g, '&#124;')
            }
            line = patchLine(line)

            output.push(line)
          }
        }
      })

      await new Promise((resolve) => lines.once('close', resolve))
      inputStream.close()

      const slug =
        id === 'index'
          ? '/api'
          : `/api/${id.replace(/\./g, '/').replaceAll(/_constructor_/g, '$constructor$')}`

      const header = [
        '---',
        `slug: ${slug}`,
        `title: ${title}`,
        'custom_edit_url: null',
        '---',
        '',
        '<div class="tsdocPage">',
        '',
      ]

      const footer = ['', '</div>']

      const mdOutputId = id
        .replace(/\./g, '/')
        .replaceAll(/_constructor_/g, '$constructor$')
      const mdOutputIdDirname = path.dirname(mdOutputId)
      let mdOutputIdBasename = path.basename(mdOutputId)
      if (/[^a-zA-Z0-9$]/.test(mdOutputIdBasename)) {
        mdOutputIdBasename = `$${mdOutputIdBasename}$`
      }

      const mdOutFilePath = join(mdOutputIdDirname, mdOutputIdBasename) + '.md'

      const mdOutFolderPath = path.dirname(
        path.join(outputFolderPath, mdOutFilePath)
      )
      await fs.mkdir(mdOutFolderPath, { recursive: true })

      const docFilePath = join(outputFolderPath, mdOutFilePath)
      // console.log(`Writing ${docFilePath}...`)
      await writeFile(
        docFilePath,
        header.concat(output).concat(footer).join('\n')
      )
    } catch (err) {
      console.error(`Could not process ${mdFileName}: ${err}`)
    }
  }
}

// ----------------------------------------------------------------------------

async function main() {
  // Parse the API JSON file
  const apiDataModel = await parseApiDataModel()
  if (apiDataModel === null) {
    return 1
  }

  const apiViewModel = prepareApiViewModel(apiDataModel)

  const sidebar = generateSidebarCategory(apiViewModel)
  // console.log(util.inspect(sidebar, { compact: false, depth: 999 }));

  // Write the sidebar to file
  try {
    console.log(`Writing sidebar file ${sidebarFilePath}`)
    const sidebarJson = JSON.stringify(sidebar, null, 2)
    await writeFile(sidebarFilePath, sidebarJson)
  } catch (err) {
    console.error(
      `Could not write sidebar file ${sidebarFilePath}: ${err.message}`
    )
    return 1
  }

  // process.exit(0);

  await generateMdFiles(apiViewModel)

  // await legacy()

  return 0
}

// ----------------------------------------------------------------------------

main()

// try {
//   process.exit(main())
// } catch (err) {
//   console.error(`Error in convert-docs.cjs: ${err.message}`);
//   process.exit(1);
// }

// ----------------------------------------------------------------------------
